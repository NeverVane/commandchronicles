Executive Summary

CommandChronicles CLI is a modern shell history management tool that enhances the default shell history with rich contextual information, powerful search capabilities, and secure local storage. It provides a seamless, non-invasive integration with bash and zsh shells while maintaining compatibility with existing shell configurations and themes.

Project Overview

Repository: [git@github.com](mailto:git@github.com)\:NeverVane/commandchronicles-cli.git
Target Platforms: Unix-like systems (Linux, macOS, BSD)
Supported Shells: bash, zsh
License: MIT
Core Binary: `ccr`
Language: Go

Product Goals

* **Enhanced History Management:** Capture comprehensive command context beyond simple text
* **Powerful Search:** Provide intuitive and fast search capabilities through both TUI and CLI interfaces
* **Security First:** Ensure all history data is encrypted at rest with zero plaintext leakage
* **Zero Friction:** Integrate seamlessly without disrupting existing shell workflows or configurations
* **Performance:** Deliver instant search results even with hundreds of thousands of history entries

Core Features

1. **Enhanced History Recording**
   The system captures and stores the following information for each command:

   * Command text
   * Exit code
   * Execution duration (milliseconds)
   * Working directory
   * Timestamp with millisecond precision
   * Session identifier (UUID)
   * Hostname
   * Git repository root (when applicable)

2. **Secure Storage**

   **Encryption Model**

   * **At Rest:** All database records encrypted using XChaCha20-Poly1305 AEAD
   * **In Memory:** Decrypted records loaded into RAM only during search operations
   * **No Plaintext:** Zero plaintext data on disk

   **Key Storage & Derivation**

   * **Deterministic Key Derivation:** User password + username → encryption key via Argon2id (time=3, memory=64MB, threads=4)

     * Same credentials always produce the same key, enabling cross-device decryption
   * **Session Key File (Optional):** `~/.local/share/commandchronicles/session`

     * Stores the derived key encrypted for convenience
     * Allows passwordless operation until timeout
     * If lost, key can be re-derived by re-entering credentials

   **Data Flow**

   1. Command executed → Captured in RAM
   2. RAM record → Encrypted → SQLite database
   3. Search initiated → Decrypt only into RAM as needed → Search performed → RAM cleared (per cache policy)

3. **Search Functionality**

   **Interactive TUI Mode**

   * Activated by pressing the up arrow key
   * Fullscreen interface with minimal, elegant design
   * Real-time fuzzy search on decrypted in-memory data
   * Visual indicators for command metadata
   * Smooth keyboard navigation

   **Hybrid Memory Management**

   * **Hot Cache:** Always keep the latest 1k commands loaded in RAM (configurable)
   * **Search Flow:**

     1. Search hot cache first
     2. If fewer than 10 matches found, load next batch (e.g., 5k commands) and retry
     3. Repeat in batches until sufficient results or end of history
     4. After search, clear all but the hot cache back into RAM
   * **Cache Maintenance:**

     * On new command: insert into cache, evict oldest if exceeding size
     * Periodic or smart refresh (every 5 min or on new session) to update cache
   * **Configuration Options**

     ```toml
     [cache]
     hot_cache_size    = 1000    # Number of recent commands always in RAM
     search_batch_size = 5000    # Batch size for deeper searches
     max_memory_mb     = 100     # Hard memory limit during search
     refresh_interval  = 300     # Seconds between cache refreshes
     ```

4. **Shell Integration**

   * Minimal shell hooks that don’t interfere with existing configurations
   * No prompt or theme modifications
   * Supports oh-my-zsh, prezto, starship, p10k
   * Graceful degradation if `ccr` binary is unavailable
   * Zero dependencies beyond the core binary

   **Command Recording Flow**

   1. Pre-execution hook: capture start time
   2. Post-execution hook: capture exit code & duration
   3. Assemble record in RAM
   4. Encrypt & write to database
   5. Clear RAM immediately after storage

5. **User Interface**

   **TUI Design Principles**

   * Minimal, elegant, informative, responsive, accessible
   * Syntax highlighting, clear metadata, smooth animations

   **CLI Features**

   * Comprehensive `ccr search` with filters
   * `ccr import` for existing shell history
   * `ccr stats` for analytics
   * Database and config management utilities

Technical Specifications

* **Database Design**

  * SQLite with encrypted JSON blobs in `encrypted_data`
  * Unencrypted indices: `timestamp`, `session`, `hostname` for filtering

* **Schema**

  ```sql
  CREATE TABLE history (
    id INTEGER PRIMARY KEY,
    encrypted_data BLOB NOT NULL,
    timestamp INTEGER NOT NULL,
    session TEXT NOT NULL,
    hostname TEXT NOT NULL,
    created_at INTEGER NOT NULL
  );
  ```

* **Performance Requirements**

  * Command capture overhead: <10ms
  * TUI launch: <50ms
  * Search (100k+ records): <200ms (with hybrid cache)
  * Memory usage: <100MB
  * DB growth: \~1KB per command

Configuration System

* Config: `~/.config/commandchronicles/config.toml`
* DB: `~/.local/share/commandchronicles/history.db`
* Session key: `~/.local/share/commandchronicles/session`

User Experience

1. **Initial Setup**

   * Install single binary
   * `ccr init`: set username & password
   * (Optional) import existing history

2. **Daily Usage**

   * Normal shell usage
   * Press ↑ to search via TUI
   * Fuzzy search + filters
   * Select to paste command into shell buffer

3. **Password Management**

   * Password prompt on first use after boot or timeout (default 3 months)
   * `ccr lock` to manually require password

Implementation Requirements

* Single binary with minimal dependencies
* Use existing fuzzy search & cryptographic libraries
* Employ a modern TUI framework
* Adhere to security-by-default and simplicity principles

Testing Requirements

* Verify encryption/decryption correctness with deterministic key
* Ensure secure memory clearing per cache policy
* Benchmark search performance with hybrid cache on large datasets
* Test shell integration across bash/zsh & popular frameworks
* Validate file permissions and cross-platform behavior

Success Metrics

* **Security:** Zero plaintext on disk, deterministic key derivation verified
* **Performance:** Sub-200ms search on 100k+ entries
* **Reliability:** No shell disruptions
* **Usability:** Intuitive TUI & CLI
* **Compatibility:** Works on Linux, macOS, BSD with bash/zsh

Constraints and Limitations

* Local-only operation (no network features)
* Initial version supports bash & zsh only
* Unix-like systems only
* Single-user design
